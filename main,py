import os
import io
from datetime import datetime
from typing import Optional, Any, Dict

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from dotenv import load_dotenv

import motor.motor_asyncio
from bson import ObjectId

load_dotenv()

MONGO_URI = os.getenv("MONGO_URI")
if not MONGO_URI:
    raise RuntimeError(
        "MONGO_URI not found. Make sure your .env is in the same folder as main.py "
        "and contains: MONGO_URI=..."
    )

client = motor.motor_asyncio.AsyncIOMotorClient(MONGO_URI)
db = client.leeMuscatDB


app = FastAPI(title="Event Management API")


def oid(id_str: str) -> ObjectId:
    """Convert string to ObjectId with validation."""
    try:
        return ObjectId(id_str)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid id format")


def to_json(doc: Dict[str, Any]) -> Dict[str, Any]:
    """Convert Mongo document to JSON-friendly dict."""
    doc["_id"] = str(doc["_id"])
    return doc


async def get_or_404(collection, id_str: str) -> Dict[str, Any]:
    doc = await collection.find_one({"_id": oid(id_str)})
    if not doc:
        raise HTTPException(status_code=404, detail="Not found")
    return doc


class Event(BaseModel):
    name: str
    description: str
    date: str
    venue_id: str
    max_attendees: int


class Attendee(BaseModel):
    name: str
    email: str
    phone: Optional[str] = None


class Venue(BaseModel):
    name: str
    address: str
    capacity: int


class Booking(BaseModel):
    event_id: str
    attendee_id: str
    ticket_type: str
    quantity: int


@app.post("/events")
async def create_event(event: Event):
    result = await db.events.insert_one(event.model_dump())
    return {"message": "Event created", "id": str(result.inserted_id)}


@app.get("/events")
async def list_events():
    docs = await db.events.find().to_list(100)
    return [to_json(d) for d in docs]


@app.get("/events/{event_id}")
async def get_event(event_id: str):
    doc = await get_or_404(db.events, event_id)
    return to_json(doc)


@app.put("/events/{event_id}")
async def update_event(event_id: str, event: Event):
    result = await db.events.update_one({"_id": oid(event_id)}, {"$set": event.model_dump()})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Event not found")
    return {"message": "Event updated"}


@app.delete("/events/{event_id}")
async def delete_event(event_id: str):
    result = await db.events.delete_one({"_id": oid(event_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Event not found")
    return {"message": "Event deleted"}


@app.post("/attendees")
async def create_attendee(attendee: Attendee):
    result = await db.attendees.insert_one(attendee.model_dump())
    return {"message": "Attendee created", "id": str(result.inserted_id)}


@app.get("/attendees")
async def list_attendees():
    docs = await db.attendees.find().to_list(100)
    return [to_json(d) for d in docs]


@app.get("/attendees/{attendee_id}")
async def get_attendee(attendee_id: str):
    doc = await get_or_404(db.attendees, attendee_id)
    return to_json(doc)


@app.put("/attendees/{attendee_id}")
async def update_attendee(attendee_id: str, attendee: Attendee):
    result = await db.attendees.update_one({"_id": oid(attendee_id)}, {"$set": attendee.model_dump()})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Attendee not found")
    return {"message": "Attendee updated"}


@app.delete("/attendees/{attendee_id}")
async def delete_attendee(attendee_id: str):
    result = await db.attendees.delete_one({"_id": oid(attendee_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Attendee not found")
    return {"message": "Attendee deleted"}


@app.post("/venues")
async def create_venue(venue: Venue):
    result = await db.venues.insert_one(venue.model_dump())
    return {"message": "Venue created", "id": str(result.inserted_id)}


@app.get("/venues")
async def list_venues():
    docs = await db.venues.find().to_list(100)
    return [to_json(d) for d in docs]


@app.get("/venues/{venue_id}")
async def get_venue(venue_id: str):
    doc = await get_or_404(db.venues, venue_id)
    return to_json(doc)


@app.put("/venues/{venue_id}")
async def update_venue(venue_id: str, venue: Venue):
    result = await db.venues.update_one({"_id": oid(venue_id)}, {"$set": venue.model_dump()})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Venue not found")
    return {"message": "Venue updated"}


@app.delete("/venues/{venue_id}")
async def delete_venue(venue_id: str):
    result = await db.venues.delete_one({"_id": oid(venue_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Venue not found")
    return {"message": "Venue deleted"}


@app.post("/booking")
async def create_booking(booking: Booking):
    result = await db.booking.insert_one(booking.model_dump())
    return {"message": "Booking created", "id": str(result.inserted_id)}


@app.get("/booking")
async def list_bookings():
    docs = await db.booking.find().to_list(100)
    return [to_json(d) for d in docs]


@app.get("/booking/{booking_id}")
async def get_booking(booking_id: str):
    doc = await get_or_404(db.booking, booking_id)
    return to_json(doc)


@app.put("/booking/{booking_id}")
async def update_booking(booking_id: str, booking: Booking):
    result = await db.booking.update_one({"_id": oid(booking_id)}, {"$set": booking.model_dump()})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Booking not found")
    return {"message": "Booking updated"}


@app.delete("/booking/{booking_id}")
async def delete_booking(booking_id: str):
    result = await db.booking.delete_one({"_id": oid(booking_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Booking not found")
    return {"message": "Booking deleted"}


async def upload_media(collection, link_field: str, link_id: str, media_type: str, file: UploadFile):
    content = await file.read()
    doc = {
        link_field: link_id,
        "media_type": media_type,
        "filename": file.filename,
        "content_type": file.content_type,
        "content": content,
        "uploaded_at": datetime.utcnow()
    }
    result = await collection.insert_one(doc)
    return {"message": "Uploaded", "id": str(result.inserted_id)}


async def stream_latest_media(collection, link_field: str, link_id: str, media_type: str):
    doc = await collection.find_one(
        {link_field: link_id, "media_type": media_type},
        sort=[("uploaded_at", -1)]
    )
    if not doc:
        raise HTTPException(status_code=404, detail="No media found")

    return StreamingResponse(
        io.BytesIO(doc["content"]),
        media_type=doc["content_type"],
        headers={"Content-Disposition": f'inline; filename="{doc["filename"]}"'}
    )


@app.post("/upload_event_poster/{event_id}")
async def upload_event_poster(event_id: str, file: UploadFile = File(...)):
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Poster must be an image")
    return await upload_media(db.media, "event_id", event_id, "event_poster", file)


@app.post("/upload_promo_video/{event_id}")
async def upload_promo_video(event_id: str, file: UploadFile = File(...)):
    if not file.content_type or not file.content_type.startswith("video/"):
        raise HTTPException(status_code=400, detail="Promo must be a video")
    return await upload_media(db.media, "event_id", event_id, "promo_video", file)


@app.post("/upload_venue_photo/{venue_id}")
async def upload_venue_photo(venue_id: str, file: UploadFile = File(...)):
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Venue photo must be an image")
    return await upload_media(db.media, "venue_id", venue_id, "venue_photo", file)


@app.get("/event_poster/{event_id}")
async def get_event_poster(event_id: str):
    return await stream_latest_media(db.media, "event_id", event_id, "event_poster")


@app.get("/promo_video/{event_id}")
async def get_promo_video(event_id: str):
    return await stream_latest_media(db.media, "event_id", event_id, "promo_video")


@app.get("/venue_photo/{venue_id}")
async def get_venue_photo(venue_id: str):
    return await stream_latest_media(db.media, "venue_id", venue_id, "venue_photo")
